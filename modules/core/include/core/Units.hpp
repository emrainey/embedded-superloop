#ifndef CORE_UNITS_HPP
#define CORE_UNITS_HPP

#include <cstdint>
#include <type_traits>

#if defined(UNITTEST)
#include <iostream>
#endif

#include "iso.hpp"
// the following headers are generated by the build system from some templates, look for them in the build/include folder.
// Add new types to UNIT_COMBOS then include here.
#include "core/units/Amperes.hpp"
#include "core/units/Volts.hpp"
#include "core/units/Ohms.hpp"
#include "core/units/Watts.hpp"
#include "core/units/Hertz.hpp"
#include "core/units/Ticks.hpp"
#include "core/units/Seconds.hpp"
#include "core/units/Meters.hpp"
#include "core/units/SquareMeters.hpp"
#include "core/units/CubicMeters.hpp"

namespace core {

namespace units {

static constexpr Ticks ticks_per_second{128U};    // 128 ticks per second

using Area = SquareMeters;
using Volume = CubicMeters;

constexpr Area operator*(Meters const& x, Meters const& y) {
    return Area{x.value() * y.value()};
}

constexpr Volume operator*(Meters const& x, Area const& y) {
    return Volume{x.value() * y.value()};
}

constexpr Volume operator*(Area const& x, Meters const& y) {
    return Volume{x.value() * y.value()};
}

constexpr Volts operator*(Amperes const& current, Ohms const& resistance) {
    return Volts{current.value() * resistance.value()};
}

constexpr Volts operator*(Ohms const& resistance, Amperes const& current) {
    return Volts{resistance.value() * current.value()};
}

constexpr Amperes operator/(Volts const& voltage, Ohms const& resistance) {
    return Amperes{voltage.value() / resistance.value()};
}

constexpr Ohms operator/(Volts const& voltage, Amperes const& current) {
    return Ohms{voltage.value() / current.value()};
}

constexpr Watts operator*(Volts const& voltage, Amperes const& current) {
    return Watts{voltage.value() * current.value()};
}

constexpr Watts operator*(Amperes const& current, Volts const& voltage) {
    return Watts{current.value() * voltage.value()};
}

constexpr Volts operator""_V(long double value) {
    return Volts{static_cast<float>(value)};
}

constexpr Volts operator""_mV(long double value) {
    return Volts{static_cast<float>(value) / 1000.0F};
}

constexpr Amperes operator""_A(long double value) {
    return Amperes{static_cast<float>(value)};
}

constexpr Amperes operator""_mA(long double value) {
    return Amperes{static_cast<float>(value) / 1000.0F};
}

constexpr Ohms operator""_Ohm(long double value) {
    return Ohms{static_cast<float>(value)};
}

constexpr Ohms operator""_kOhm(long double value) {
    return Ohms{static_cast<float>(value) * 1000.0F};
}

constexpr Watts operator""_W(long double value) {
    return Watts{static_cast<float>(value)};
}

constexpr Watts operator""_mW(long double value) {
    return Watts{static_cast<float>(value) / 1000.0F};
}

constexpr Hertz operator""_Hz(unsigned long long value) {
    return Hertz{static_cast<std::uint32_t>(value)};
}

constexpr Hertz operator""_kHz(unsigned long long value) {
    return Hertz{static_cast<std::uint32_t>(value) * iso::prefix::kilo};
}

constexpr Hertz operator""_MHz(unsigned long long value) {
    return Hertz{static_cast<std::uint32_t>(value) * iso::prefix::mega};
}

constexpr Seconds operator""_sec(long double value) {
    return Seconds{static_cast<float>(value)};
}

constexpr Seconds operator""_msec(long double value) {
    return Seconds{static_cast<float>(value) / 1E3F};
}

constexpr Seconds operator""_usec(long double value) {
    return Seconds{static_cast<float>(value) / 1E6F};
}

constexpr Ticks operator""_ticks(unsigned long long value) {
    return Ticks{static_cast<std::uint32_t>(value)};
}

constexpr Ticks ConvertToTicks(Seconds const& time) {
    // e.g. 1/2 seconds = 1/2 * 128 ticks = 64.0 ticks
    float fraction = time.value() * ticks_per_second.value();
    return Ticks{static_cast<std::uint32_t>(fraction)};
}

constexpr Seconds ConvertToSeconds(Ticks const& ticks) {
    // e.g. 64 ticks = 64 / 128 seconds = 0.5 seconds
    float fraction = static_cast<float>(ticks.value()) / static_cast<float>(ticks_per_second.value());
    return Seconds{fraction};
}

constexpr Seconds operator/(float scalar, Hertz const& frequency) {
    float fraction = scalar / static_cast<float>(frequency.value());
    return Seconds{fraction};
}

}    // namespace units

}    // namespace core

#endif    // CORE_UNIT_HPP